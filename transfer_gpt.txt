def draw_asc_flow_matplotlib(
    asc,
    start_state: str,
    prob_threshold: float = 0.0,
    terminal_clone_scope: str = "none",      # "none" | "action" | "layer"
    which_terminals=None,
    figsize=(12, 7),
    title=None,
    hscale: float = 1.6,
    *,
    probs_attr: str = "auto",                # which probabilities to use for labels/widths
    state_text_rotation: float = 0.0,
    action_text_rotation: float = 0.0,
    terminal_text_rotation: float = 0.0,
    edge_label_rotation: "float|str|None" = "auto",   # "auto", number, or None
):
    """
    Draw an ASC flow chart.

    Notes
    -----
    - Does NOT require build_flow_layers(...) to know about `probs_attr`.
      We recompute each A->target probability here from `asc.actions[*]`.
    - Deduplicates overlapping A->target edges (keeps the maximum p).
    - Labels are above shapes; axes bounds are dynamic to avoid clipping.
    - Even-layer vertical positions are computed jointly for real states AND
      terminal clones so rectangles don't overlap or bunch at the bottom.
    """
    import math
    from collections import defaultdict
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch, Rectangle, Circle

    # ---------------- sizes ----------------
    RECT_W, RECT_H = 0.06, 0.09
    CIRCLE_R = 0.035
    LABEL_DY = 0.02

    # ------------- build skeleton (no probs_attr here) -------------
    state_layers, action_layers, edges_raw, term_clones = build_flow_layers(
        asc,
        start_state=start_state,
        prob_threshold=prob_threshold,
        terminal_clone_scope=terminal_clone_scope,
        which_terminals=which_terminals,
    )

    # ------------- pick probabilities (auto/real/model) -------------
    def _get_probs_dict(a_obj):
        if probs_attr == "real":
            return getattr(a_obj, "real_probabilities", {}) or {}
        if probs_attr == "model":
            return getattr(a_obj, "probabilities", {}) or {}
        # auto
        rp = getattr(a_obj, "real_probabilities", None)
        return rp if rp else (getattr(a_obj, "probabilities", {}) or {})

    def _lookup_prob(action_name: str, target_name: str) -> float:
        """Return p for (action -> target) using selected probs; supports both shapes."""
        a_obj = asc.actions[action_name]
        probs = _get_probs_dict(a_obj)

        # unwrap clone name -> base terminal
        base_target = target_name
        if target_name in term_clones:
            base_target = term_clones[target_name]["base"]

        if not isinstance(probs, dict) or not probs:
            return 0.0

        # Nested (pre_state -> post_state -> p)?
        if any(isinstance(v, dict) for v in probs.values()):
            best = None
            for row in probs.values():
                if isinstance(row, dict) and base_target in row and row[base_target] is not None:
                    val = float(row[base_target])
                    best = val if best is None else max(best, val)
            return best if best is not None else 0.0
        # Flat (post_state -> p)
        val = probs.get(base_target, 0.0)
        return float(val) if val is not None else 0.0

    # ---------- dedupe A->target edges (keep S->A as-is), aggregation = MAX ----------
    edges_SA = []
    acc = {}  # (action, target) -> max p
    for u, v, data in edges_raw:
        if (u in state_layers) and (v in action_layers):    # S->A
            edges_SA.append((u, v, {"p": None, "label": None}))
        else:                                               # A->target
            p = _lookup_prob(u, v)
            key = (u, v)
            acc[key] = max(acc.get(key, p), p)

    edges_AT = [(u, v, {"p": float(p), "label": f"{p:.3f}"}) for (u, v), p in acc.items()]
    edges = edges_SA + edges_AT

    # ---------------- layout helpers ----------------
    def positions_by_layer(names, layer_map):
        by_layer = defaultdict(list)
        for n in names:
            by_layer[layer_map[n]].append(n)
        pos = {}
        for L, nodes in by_layer.items():
            nodes = sorted(nodes)
            m = len(nodes)
            ys = [0.0] if m == 1 else [1 - 2 * i / (m - 1) for i in range(m)]
            for n, y in zip(nodes, ys):
                pos[n] = (L, y)
        return pos

    # actions (odd columns) use the simple spread
    action_names = list(action_layers.keys())
    pos_actions = positions_by_layer(action_names, action_layers)

    # ----------- NEW: pack real states + clones together per even layer -----------
    clone_names = set(term_clones.keys())
    state_names = [s for s in state_layers if s not in clone_names]

    layer_to_items = defaultdict(list)  # L -> [("state", name) or ("clone", name)]
    for s in state_names:
        layer_to_items[state_layers[s]].append(("state", s))
    for c in clone_names:
        layer_to_items[state_layers[c]].append(("clone", c))

    pos_states, pos_clones = {}, {}
    for L, items in layer_to_items.items():
        # deterministic order: states first alphabetically, then clones alphabetically
        items = sorted(items, key=lambda t: (t[0] != "state", t[1]))
        m = len(items)
        ys = [0.0] if m == 1 else [1 - 2 * i / (m - 1) for i in range(m)]
        for (kind, name), y in zip(items, ys):
            if kind == "state":
                pos_states[name] = (L, y)
            else:
                pos_clones[name] = (L, y)

    # --------------- normalize X to [0, hscale] ---------------
    all_layers = list(state_layers.values()) + list(action_layers.values())
    Lmin, Lmax = min(all_layers), max(all_layers)

    def xnorm(L):
        return 0.0 if Lmax == Lmin else ((L - Lmin) / (Lmax - Lmin)) * hscale

    # ---------------- drawing ----------------
    fig, ax = plt.subplots(figsize=figsize, constrained_layout=True)
    ax.axis("off")
    if title:
        ax.set_title(title)

    # states
    for s in state_names:
        xL, y = pos_states[s]
        x = xnorm(xL)
        ax.add_patch(Rectangle((x - RECT_W/2, y - RECT_H/2), RECT_W, RECT_H, ec="black", fc="white"))
        ax.text(x, y + RECT_H/2 + LABEL_DY, s, fontsize=9, ha="center", va="bottom",
                rotation=state_text_rotation, rotation_mode="anchor")

    # actions
    for a in action_names:
        xL, y = pos_actions[a]
        x = xnorm(xL)
        ax.add_patch(Circle((x, y), CIRCLE_R, ec="black", fc="lightgrey"))
        ax.text(x, y + CIRCLE_R + LABEL_DY, a, fontsize=9, ha="center", va="bottom",
                rotation=action_text_rotation, rotation_mode="anchor")

    # clones (draw with base label)
    for clone, (cxL, cy) in pos_clones.items():
        x = xnorm(cxL)
        base = term_clones[clone]["base"]
        ax.add_patch(Rectangle((x - RECT_W/2, cy - RECT_H/2), RECT_W, RECT_H, ec="black", fc="white"))
        ax.text(x, cy + RECT_H/2 + LABEL_DY, base, fontsize=9, ha="center", va="bottom",
                rotation=terminal_text_rotation, rotation_mode="anchor")

    # edges
    def arrow(xy0, xy1, label=None, lw=1.0):
        ax.add_patch(FancyArrowPatch(xy0, xy1, arrowstyle="-|>", lw=lw, color="black", mutation_scale=20))
        if label:
            xm = (xy0[0] + xy1[0]) / 2
            ym = (xy0[1] + xy1[1]) / 2
            if isinstance(edge_label_rotation, (int, float)):
                rot = float(edge_label_rotation)
            elif edge_label_rotation == "auto":
                rot = math.degrees(math.atan2(xy1[1] - xy0[1], xy1[0] - xy0[0]))
                if rot < -90 or rot > 90:
                    rot += 180
            else:
                rot = 0.0
            ax.annotate(label, (xm, ym), xytext=(0, 4), textcoords="offset points",
                        fontsize=8, ha="center", va="bottom",
                        rotation=rot, rotation_mode="anchor", clip_on=False)

    def get_xy(node):
        if node in pos_states:
            xL, y = pos_states[node]
        elif node in pos_actions:
            xL, y = pos_actions[node]
        else:
            xL, y = pos_clones[node]
        return (xnorm(xL), y)

    START_OFFSET = 0.05
    END_OFFSET   = 0.05

    # collect extents for autoscale
    xs, ys = [], []
    def add_rect_extents(x, y):
        xs.extend([x - RECT_W/2, x + RECT_W/2])
        ys.extend([y - RECT_H/2 - 0.02, y + RECT_H/2 + LABEL_DY + 0.02])
    def add_circle_extents(x, y):
        xs.extend([x - CIRCLE_R, x + CIRCLE_R])
        ys.extend([y - CIRCLE_R - 0.02, y + CIRCLE_R + LABEL_DY + 0.02])

    for _, (xL, y) in pos_states.items():
        add_rect_extents(xnorm(xL), y)
    for _, (xL, y) in pos_actions.items():
        add_circle_extents(xnorm(xL), y)
    for _, (xL, y) in pos_clones.items():
        add_rect_extents(xnorm(xL), y)

    # draw deduped edges
    for u, v, data in edges:
        x0, y0 = get_xy(u)
        x1, y1 = get_xy(v)
        p = data.get("p")
        lw = 1.0 if p is None else 1.0 + 3.0 * p
        arrow((x0 + START_OFFSET, y0), (x1 - END_OFFSET, y1),
              label=data.get("label"), lw=lw)

    # dynamic bounds to avoid clipping
    if xs and ys:
        pad_x, pad_y = 0.06, 0.10
        ax.set_xlim(min(xs) - pad_x, max(xs) + pad_x)
        ax.set_ylim(min(ys) - pad_y, max(ys) + pad_y)
    ax.margins(x=0.02, y=0.04)

    return fig, ax
