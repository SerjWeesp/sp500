def draw_asc_flow_matplotlib(
    asc,
    start_state: str,
    prob_threshold: float = 0.0,
    terminal_clone_scope: str = "none",      # "none" | "action" | "layer"
    which_terminals=None,
    figsize=(12, 7),
    title=None,
    hscale: float = 1.6,
    *,
    probs_attr: str = "auto",                # "auto" (prefer real_probabilities) | "real" | "model"
    # node text (now inside shapes)
    max_fontsize: int = 10,
    min_fontsize: int = 6,
    # edge label behavior
    edge_label_rotation: "float|str|None" = "auto",   # "auto" | number | None
    label_pos: float = 0.60,                           # 60% along arrow length
    label_offset_pts: int = 4,
    # edge styles
    sa_linestyle = "--",                               # State→Action edges
    at_linestyle = "-",                                # Action→(state/clone) edges
    bend_left: bool = True,                            # bend left-going arrows
    bend_rad: float = 0.18,
    bend_min_dx: float = 0.02,
):
    import math
    import numpy as np
    from collections import defaultdict
    import matplotlib.pyplot as plt
    from matplotlib.patches import FancyArrowPatch, Rectangle, Circle

    # ------------ sizes (data units) ------------
    RECT_W, RECT_H = 0.06, 0.09
    CIRCLE_R = 0.035
    TOP_PAD = 0.02   # kept for autoscale headroom

    # ------------ helpers ------------
    def _safe_prob(val):
        try:
            p = float(val)
        except (TypeError, ValueError):
            return 0.0
        if not math.isfinite(p): return 0.0
        return 0.0 if p < 0 else (1.0 if p > 1 else p)

    def _point_and_angle_on_path(patch, frac: float):
        path = patch.get_path().transformed(patch.get_transform())
        V = path.vertices
        if V.shape[0] < 2:
            return (V[-1,0], V[-1,1]), 0.0
        seg = np.hypot(np.diff(V[:,0]), np.diff(V[:,1]))
        if not np.any(seg > 0):
            return (V[-1,0], V[-1,1]), 0.0
        cum = np.concatenate([[0.0], np.cumsum(seg)])
        L = cum[-1]; s = np.clip(frac, 0.0, 1.0) * L
        i = int(np.searchsorted(cum, s) - 1); i = max(0, min(i, len(seg)-1))
        if seg[i] == 0:
            x, y = V[i]; dx, dy = 1.0, 0.0
        else:
            t = (s - cum[i]) / seg[i]
            x = (1-t)*V[i,0] + t*V[i+1,0]; y = (1-t)*V[i,1] + t*V[i+1,1]
            dx = V[i+1,0]-V[i,0]; dy = V[i+1,1]-V[i,1]
        ang = math.degrees(math.atan2(dy, dx))
        if ang < -90 or ang > 90: ang += 180
        return (x, y), ang

    def _fit_text_inside(ax, x, y, w, h, text, *, is_circle=False,
                         max_fs=10, min_fs=6, pad_pts=4):
        fig = ax.figure
        if is_circle:
            w_data = h_data = 2 * CIRCLE_R / math.sqrt(2)  # inscribed square
        else:
            w_data, h_data = w, h
        (x0d, y0d) = ax.transData.transform((x - w_data/2, y - h_data/2))
        (x1d, y1d) = ax.transData.transform((x + w_data/2, y + h_data/2))
        box_w = abs(x1d - x0d) - 2*pad_pts
        box_h = abs(y1d - y0d) - 2*pad_pts

        t = ax.text(x, y, text, ha="center", va="center", fontsize=max_fs, wrap=True)
        fig.canvas.draw(); ren = fig.canvas.get_renderer()

        def measure(txt):
            bb = txt.get_window_extent(renderer=ren)
            return bb.width, bb.height

        words = text.split()
        best_lines = [text]; fs = max_fs
        while fs >= min_fs:
            t.set_fontsize(fs)
            # greedy wrap by width
            lines, cur = [], ""
            for w_ in words:
                cand = (cur + " " + w_).strip()
                t.set_text(cand if not lines else "\n".join(lines + [cand]))
                wpx, _ = measure(t)
                if wpx <= box_w:
                    cur = cand
                else:
                    if cur:
                        lines.append(cur); cur = w_
                    else:
                        lines.append(w_); cur = ""
            if cur: lines.append(cur)
            t.set_text("\n".join(lines))
            wpx, hpx = measure(t)
            if wpx <= box_w and hpx <= box_h:
                best_lines = lines; break
            fs -= 1
        t.set_fontsize(fs); t.set_text("\n".join(best_lines))
        return t

    # ----- choose probability dict for recomputation -----
    def _probs_for_action(a_obj):
        if probs_attr == "real":
            return getattr(a_obj, "real_probabilities", {}) or {}
        if probs_attr == "model":
            return getattr(a_obj, "probabilities", {}) or {}
        rp = getattr(a_obj, "real_probabilities", None)
        return rp if rp else (getattr(a_obj, "probabilities", {}) or {})

    def _lookup_prob(action_name: str, target_name: str) -> float:
        a_obj = asc.actions[action_name]
        probs = _probs_for_action(a_obj)
        # if target is a clone use its base
        base = target_name.split("|")[0] if "|" in target_name else target_name
        if not isinstance(probs, dict) or not probs:
            return 0.0
        if any(isinstance(v, dict) for v in probs.values()):
            best = None
            for row in probs.values():
                if isinstance(row, dict) and base in row and row[base] is not None:
                    val = float(row[base])
                    best = val if best is None else max(best, val)
            return 0.0 if best is None else best
        return float(probs.get(base, 0.0) or 0.0)

    # ------------ build skeleton ------------
    state_layers, action_layers, edges_raw, term_clones = build_flow_layers(
        asc,
        start_state=start_state,
        prob_threshold=prob_threshold,
        terminal_clone_scope=terminal_clone_scope,
        which_terminals=which_terminals,
    )

    # ------------ recompute + dedupe A→target ------------
    edges_SA = []
    acc = {}  # (A, T) -> p_max
    for u, v, data in edges_raw:
        if (u in state_layers) and (v in action_layers):
            edges_SA.append((u, v, {"p": None, "label": None}))
        else:
            p = _lookup_prob(u, v)
            acc[(u, v)] = max(acc.get((u, v), p), p)
    edges_AT = [(u, v, {"p": float(p), "label": f"{float(p):.3f}"}) for (u, v), p in acc.items()]
    edges = edges_SA + edges_AT

    # ------------ layout (pack states + clones together per even layer) ------------
    def positions_by_layer(names, layer_map):
        byL = defaultdict(list)
        for n in names: byL[layer_map[n]].append(n)
        pos = {}
        for L, nodes in byL.items():
            nodes = sorted(nodes); m = len(nodes)
            ys = [0.0] if m == 1 else [1 - 2*i/(m-1) for i in range(m)]
            for n, y in zip(nodes, ys): pos[n] = (L, y)
        return pos

    action_names = list(action_layers.keys())
    pos_actions = positions_by_layer(action_names, action_layers)

    clone_names = set(term_clones.keys())
    state_names = [s for s in state_layers if s not in clone_names]
    by_even = defaultdict(list)
    for s in state_names: by_even[state_layers[s]].append(("state", s))
    for c in clone_names: by_even[state_layers[c]].append(("clone", c))
    pos_states, pos_clones = {}, {}
    for L, items in by_even.items():
        items = sorted(items, key=lambda t: (t[0] != "state", t[1]))
        m = len(items); ys = [0.0] if m == 1 else [1 - 2*i/(m-1) for i in range(m)]
        for (kind, name), y in zip(items, ys):
            (pos_states if kind == "state" else pos_clones)[name] = (L, y)

    allL = list(state_layers.values()) + list(action_layers.values())
    Lmin, Lmax = min(allL), max(allL)
    def xnorm(L): return 0.0 if Lmax == Lmin else ((L - Lmin) / (Lmax - Lmin)) * hscale

    # ------------ drawing ------------
    fig, ax = plt.subplots(figsize=figsize, constrained_layout=True)
    ax.axis("off")
    if title: ax.set_title(title)

    # nodes with text INSIDE
    for s in state_names:
        xL, y = pos_states[s]; x = xnorm(xL)
        ax.add_patch(Rectangle((x - RECT_W/2, y - RECT_H/2), RECT_W, RECT_H, ec="black", fc="white"))
        _fit_text_inside(ax, x, y, RECT_W, RECT_H, s, is_circle=False,
                         max_fs=max_fontsize, min_fs=min_fontsize)

    for a in action_names:
        xL, y = pos_actions[a]; x = xnorm(xL)
        ax.add_patch(Circle((x, y), CIRCLE_R, ec="black", fc="lightgrey"))
        _fit_text_inside(ax, x, y, 2*CIRCLE_R, 2*CIRCLE_R, a, is_circle=True,
                         max_fs=max_fontsize, min_fs=min_fontsize)

    for clone, (xL, y) in pos_clones.items():
        x = xnorm(xL); base = term_clones[clone]["base"]
        ax.add_patch(Rectangle((x - RECT_W/2, y - RECT_H/2), RECT_W, RECT_H, ec="black", fc="white"))
        _fit_text_inside(ax, x, y, RECT_W, RECT_H, base, is_circle=False,
                         max_fs=max_fontsize, min_fs=min_fontsize)

    def get_xy(node):
        if node in pos_states:  xL, y = pos_states[node]
        elif node in pos_actions: xL, y = pos_actions[node]
        else:                   xL, y = pos_clones[node]
        return (xnorm(xL), y)

    def arrow(xy0, xy1, *, label=None, lw=1.0, linestyle="-"):
        x0, y0 = xy0; x1, y1 = xy1
        dx, dy = (x1-x0), (y1-y0)
        if bend_left and (dx < -bend_min_dx):
            sgn = 1 if dy >= 0 else -1
            conn = f"arc3,rad={sgn * bend_rad}"
        else:
            conn = "arc3,rad=0"
        patch = FancyArrowPatch(
            xy0, xy1, arrowstyle="-|>", lw=lw, color="black",
            linestyle=linestyle, capstyle="butt", joinstyle="miter",
            mutation_scale=20, connectionstyle=conn,
        )
        ax.add_patch(patch)
        if label is not None:
            (xm, ym), auto_ang = _point_and_angle_on_path(patch, label_pos)
            if isinstance(edge_label_rotation, (int, float)):
                rot = float(edge_label_rotation)
            elif edge_label_rotation == "auto":
                rot = auto_ang
            else:
                rot = 0.0
            ax.annotate(label, (xm, ym), xytext=(0, label_offset_pts),
                        textcoords="offset points", fontsize=8,
                        ha="center", va="bottom",
                        rotation=rot, rotation_mode="anchor",
                        clip_on=False)

    START_OFFSET, END_OFFSET = 0.05, 0.05

    # edges (S→A dashed, A→target solid; labels always from recomputed p)
    for u, v, data in edges:
        x0, y0 = get_xy(u); x1, y1 = get_xy(v)
        is_SA = (u in pos_states) and (v in pos_actions)
        ls    = sa_linestyle if is_SA else at_linestyle
        if is_SA:
            lw = 1.0
            label = None
        else:
            p = _lookup_prob(u, v)  # recompute regardless of builder payload
            lw = 1.0 + 3.0 * _safe_prob(p)
            label = f"{_safe_prob(p):.3f}"
        arrow((x0 + START_OFFSET, y0), (x1 - END_OFFSET, y1),
              label=label, lw=lw, linestyle=ls)

    # autoscale
    xs, ys = [], []
    def add_rect_extents(x, y):
        xs.extend([x - RECT_W/2, x + RECT_W/2])
        ys.extend([y - RECT_H/2 - 0.02, y + RECT_H/2 + TOP_PAD + 0.02])
    def add_circle_extents(x, y):
        xs.extend([x - CIRCLE_R, x + CIRCLE_R])
        ys.extend([y - CIRCLE_R - 0.02, y + CIRCLE_R + TOP_PAD + 0.02])
    for _, (xL, y) in pos_states.items():  add_rect_extents(xnorm(xL), y)
    for _, (xL, y) in pos_actions.items(): add_circle_extents(xnorm(xL), y)
    for _, (xL, y) in pos_clones.items():  add_rect_extents(xnorm(xL), y)
    if xs and ys:
        ax.set_xlim(min(xs) - 0.06, max(xs) + 0.06)
        ax.set_ylim(min(ys) - 0.10, max(ys) + 0.10)
    ax.margins(x=0.02, y=0.04)

    return fig, ax