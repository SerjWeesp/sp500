import pandas as pd
from typing import Any, Dict, Iterable, Optional


def build_transition_table_mixed_sources(
    asc_main,                      # states, actions, probabilities
    asc_rewards,                   # rewards + rewards_dev only
    *,
    prob_threshold: float = 0.0,
    probs_attr: str = "auto",      # "auto" | "real" | "model"
    # optional filters if you want later to control width:
    include_only: Optional[Iterable[str]] = None,  # keep only these action attrs (names)
    exclude: Optional[Iterable[str]] = None,       # drop these action attrs (names)
) -> pd.DataFrame:
    """
    One row per (pre_state --action--> post_state).
    Probabilities & topology -> asc_main; rewards/rewards_dev -> asc_rewards.
    """

    # ---------- helpers ----------
    def action_public_attrs(a: Any,
                            prefix: str = "action_",
                            include_only: Optional[Iterable[str]] = None,
                            exclude: Optional[Iterable[str]] = None) -> Dict[str, Any]:
        """
        Collect ALL non-callable, non-private attributes from the action
        (including dicts/lists/objects) and prefix their column names.
        """
        excl = set(exclude or ())
        inc  = set(include_only or ())
        out: Dict[str, Any] = {}
        for k in dir(a):
            if k.startswith("_"):
                continue
            if include_only and k not in inc:
                continue
            if k in excl:
                continue
            try:
                v = getattr(a, k)
            except Exception:
                continue
            if callable(v):
                continue
            out[f"{prefix}{k}"] = v
        return out

    def from_states_for_action(asc_obj, a_obj) -> Iterable[str]:
        fs = getattr(a_obj, "from_states", None)
        return list(fs) if fs else list(asc_obj.states.keys())

    def is_terminal_state(asc_obj, s: str) -> bool:
        st = asc_obj.states.get(s)
        if st is None:
            return True
        if getattr(st, "is_terminal", False):
            return True
        if not getattr(st, "actions", []):
            return True
        for _a, _ao in asc_obj.actions.items():
            fs = getattr(_ao, "from_states", None)
            if fs and s in fs:
                return False
        return True

    def pick_probs_dict(a) -> Dict[str, Any]:
        if probs_attr == "real":
            return getattr(a, "real_probabilities", {}) or {}
        if probs_attr == "model":
            return getattr(a, "probabilities", {}) or {}
        rp = getattr(a, "real_probabilities", None)
        return rp if rp else (getattr(a, "probabilities", {}) or {})

    def iter_successors(a_obj, pre_state=None):
        probs = pick_probs_dict(a_obj)
        if not isinstance(probs, dict):
            return
        if probs and any(isinstance(v, dict) for v in probs.values()):
            row = probs.get(pre_state, {}) if pre_state is not None else {}
            for post, p in row.items():
                if p is not None and float(p) >= prob_threshold:
                    yield post, float(p)
        else:
            for post, p in probs.items():
                if p is not None and float(p) >= prob_threshold:
                    yield post, float(p)

    def lookup_reward(a_rewards_obj, pre_state, post_state, key: str) -> Optional[float]:
        src = getattr(a_rewards_obj, key, None)
        if not isinstance(src, dict):
            return None
        base_post = post_state.split("|")[0] if "|" in post_state else post_state
        if src and any(isinstance(v, dict) for v in src.values()):
            return float(src.get(pre_state, {}).get(base_post, 0.0))
        return float(src.get(base_post, 0.0))

    # ---------- main ----------
    rows = []
    for a_name, a_main in asc_main.actions.items():
        # attributes from asc_main (ALL public attrs)
        a_attrs = action_public_attrs(
            a_main, prefix="action_",
            include_only=include_only, exclude=exclude
        )
        # rewards source for this action
        aR = (asc_rewards.actions.get(a_name) if asc_rewards else None) or a_main

        for s in from_states_for_action(asc_main, a_main):
            for s_prime, p in iter_successors(a_main, pre_state=s):
                rows.append({
                    "action_name":       a_name,
                    "action_from_state": s,
                    "action_to_state":   s_prime,
                    "prob":              float(p),
                    "reward":            lookup_reward(aR, s, s_prime, "rewards"),
                    "reward_dev":        lookup_reward(aR, s, s_prime, "rewards_dev"),
                    "is_terminal":       is_terminal_state(asc_main, s_prime),
                    **a_attrs,  # <- all public attrs from asc_main
                })

    return pd.DataFrame(rows)
