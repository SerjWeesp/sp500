state_layers, action_layers, edges, term_clones = build_flow_layers(
    asc,
    start_state=start_state,
    prob_threshold=prob_threshold,
    split_terminals_by_action=split_terminals_by_action,
    which_terminals=which_terminals,
)

# --- NEW: collapse per-action terminal clones to a single node per base ---
if merge_terminal_targets and term_clones:
    # Map clone -> base, and collect incoming actions per base
    clone_to_base = {clone: meta["base"] for clone, meta in term_clones.items()}
    base_incoming_layers = defaultdict(list)
    for u, v, _data in edges:
        if v in clone_to_base:
            base = clone_to_base[v]
            if u in action_layers:
                base_incoming_layers[base].append(action_layers[u])

    # Place each base terminal one layer to the right of its rightmost incoming action
    for base, incoming in base_incoming_layers.items():
        layer = (max(incoming) + 1) if incoming else (max(action_layers.values()) + 1)
        state_layers[base] = max(state_layers.get(base, layer), layer)

    # Rewrite edges to point to base; drop true clone nodes from layers
    new_edges = []
    for u, v, data in edges:
        v2 = clone_to_base.get(v, v)
        new_edges.append((u, v2, data))
    edges = new_edges

    # Remove clones from the layer map so we only draw each terminal once
    for clone in list(term_clones.keys()):
        state_layers.pop(clone, None)

    # After merging, clones donâ€™t need special positioning any more
    term_clones = {}
