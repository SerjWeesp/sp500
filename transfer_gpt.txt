import pandas as pd
import json
from collections import defaultdict

# --- your existing helpers (unchanged) ---
def iter_action_successors(action_obj, pre_state=None, prob_threshold=0.0):
    probs = getattr(action_obj, "probabilities", {}) or {}
    if any(isinstance(v, dict) for v in probs.values()):
        row = probs.get(pre_state, {}) if pre_state is not None else {}
        for post_s, p in row.items():
            if p and float(p) >= prob_threshold:
                yield post_s, float(p)
    else:
        for post_s, p in probs.items():
            if p and float(p) >= prob_threshold:
                yield post_s, float(p)

def all_from_states(asc):
    res = set()
    for _, a_obj in getattr(asc, "actions", {}).items():
        fs = getattr(a_obj, "from_states", None)
        if fs:
            res.update(fs)
    return res

def is_terminal_state(asc, s, from_states_cache=None):
    st = asc.states.get(s)
    if st is None:
        return True
    if getattr(st, "is_terminal", False):
        return True
    if not getattr(st, "actions", []):
        return True
    if from_states_cache is not None and s not in from_states_cache:
        return True
    return False
# -----------------------------------------

def _from_states_for_action(asc, a_name, a_obj):
    fs = sorted([s for s, sobj in asc.states.items()
                 if getattr(sobj, "actions", None) and a_name in sobj.actions])
    if fs:
        return fs
    probs = getattr(a_obj, "probabilities", {}) or {}
    if probs and any(isinstance(v, dict) for v in probs.values()):
        return list(probs.keys())
    return [None]

def _serialize_attr(val):
    """Make any attribute value dataframe-friendly."""
    # Keep simple scalars/lists/tuples/dicts; JSON for complex/numpy/torch objects
    if isinstance(val, (str, int, float, bool)) or val is None:
        return val
    if isinstance(val, (list, tuple)):
        try:
            return json.dumps(val)
        except Exception:
            return str(val)
    if isinstance(val, dict):
        try:
            return json.dumps(val)
        except Exception:
            return str(val)
    # e.g., numpy/tensor/custom objects
    try:
        return float(val)  # best effort for number-like
    except Exception:
        return str(val)

def _action_public_attrs(a_obj):
    """
    Collect all non-callable, non-private attributes from the Action object.
    Returned as dict with 'action__<attr>' keys to avoid name clashes.
    """
    out = {}
    for name in dir(a_obj):
        if name.startswith("_"):
            continue
        try:
            val = getattr(a_obj, name)
        except Exception:
            continue
        # skip callables and descriptors
        if callable(val):
            continue
        out[f"action__{name}"] = _serialize_attr(val)
    return out

def asc_to_transition_table(asc, *, ascmdp=None, gamma=None, prob_threshold=0.0):
    """
    Build a flat table of transitions and include ALL Action attributes as columns
    (prefixed with action__).
    Rows are sorted by action_from_state in the same order as asc.states.
    """
    rows = []
    from_states_cache = all_from_states(asc)

    # state order mapping (dict preserves insertion order)
    state_order = {s: i for i, s in enumerate(asc.states.keys())}

    for a_name, a_obj in asc.actions.items():
        # snapshot all action attributes once (will copy per row)
        a_attrs = _action_public_attrs(a_obj)

        for s in _from_states_for_action(asc, a_name, a_obj):
            for s_prime, p in iter_action_successors(a_obj, pre_state=s, prob_threshold=prob_threshold):
                # probability
                prob = float(p)

                # reward (prefer MDP wrapper if provided)
                reward = None
                reward_dev = None
                if ascmdp is not None and hasattr(ascmdp, "R"):
                    try:
                        reward = float(ascmdp.R(s, a_name, s_prime))
                    except Exception:
                        reward = None
                else:
                    rw = getattr(a_obj, "rewards", {})
                    if isinstance(rw, dict):
                        if s is not None and isinstance(rw.get(s), dict):
                            reward = float(rw.get(s, {}).get(s_prime, 0.0))
                        else:
                            reward = float(rw.get(s_prime, 0.0))
                    rw_dev = getattr(a_obj, "rewards_dev", {})
                    if isinstance(rw_dev, dict):
                        if s is not None and isinstance(rw_dev.get(s), dict):
                            reward_dev = float(rw_dev.get(s, {}).get(s_prime, 0.0))
                        else:
                            reward_dev = float(rw_dev.get(s_prime, 0.0))

                terminal = is_terminal_state(asc, s_prime, from_states_cache)

                base = {
                    "action_name": a_name,
                    "action_from_state": s,
                    "to_state": s_prime,
                    "prob": prob,
                    "reward": reward,
                    "reward_dev": reward_dev,
                    "discount": gamma,
                    "is_terminal": terminal,
                    "_state_rank": state_order.get(s, 10**9) if s is not None else -1,
                }

                base.update(a_attrs)  # add all action attributes as columns
                rows.append(base)

    df = pd.DataFrame(rows)

    # Sort by the asc.states order (via _state_rank), then by action_name, to_state
    df = df.sort_values(
        by=["_state_rank", "action_from_state", "action_name", "to_state"],
        kind="mergesort"  # stable
    ).drop(columns=["_state_rank"]).reset_index(drop=True)

    return df
